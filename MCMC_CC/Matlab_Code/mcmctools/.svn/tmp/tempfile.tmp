function [ string ] = struct2comment( s, name, type )
%struct2comment converts a structure s into a comment, whose style is
%specified by variable type. The name field should be a string consisting
%of whatever you would like the variable to be named if reimported.
%   
%   Suppose we have a complex structure like the CONFIG variable generated
%   by Configure.m. I
%   Example:
%   
%   global CONFIG;
%   Configure('set');
%   struct2comment(CONFIG,'META','latex')
%

if(~ischar(type))
    error('type must be a character string');
end

%Show what type is being displayed for reimporting back into Matlab
string  = sprintf(['#DISPTYPE = ' type '\n']);

switch type
    case 'text'
        %Display the variable name
        string = [string, sprintf(['#VARIABLE = ' name '\n'])];
        %get the structure's internals with seperate function-call
        structureguts = structcrawl(s,type,{name});
        string = [string, structureguts];
        
    case 'latex'
    	
	string = [string, sprintf(['#VARIABLE = ' name '\n'])];
	structureguts = structcrawl(s,type,{name});
        string = [string, structureguts];
       
        PREAMBLE = '';
    	PREAMBLE = [PREAMBLE,sprintf('%s\n','\documentclass{article}')];
	PREAMBLE = [PREAMBLE,sprintf('%s\n','\usepackage{amsmath}')];
	PREAMBLE = [PREAMBLE,sprintf('%s\n','\usepackage{pstricks}')];
	PREAMBLE = [PREAMBLE,sprintf('%s\n','\begin{document}')];
	PREAMBLE = [PREAMBLE,sprintf('%s\n','\begin{verbatim}')];
	
	string = [PREAMBLE,string];
	
	DOCEND = [];
	DOCEND = [DOCEND,sprintf('%s\n','\end{verbatim}')];
	DOCEND = [DOCEND,sprintf('%s\n','\end{document}')];
	
	string = [string,DOCEND];
	
    otherwise
        error([type ' is an unknown display type.']);
end

end

function  result = structcrawl( s, type, parent )
%A recursive funtion that performs a depth first search to display the
%names and values of all the structure's variables.

F = fieldnames(s);
Vals = struct2cell(s);
result = '';
for i = 1:length(F)    
    switch type
        case 'text'
            %Determine what type of data the value is, and translate
            %appropriately
            Class= class(Vals{i});
            switch Class
                %T/F: stored as 'true' and 'false' as opposed to Matlab's
                %1/0 convention.
                case 'logical'
                    if(Vals{i})
                        result = [result, sprintf(['#TYPE ' Class ' ' F{i} ' = true\n'])];
                    else
                        result = [result, sprintf(['#TYPE ' Class ' ' F{i} ' = false\n'])];
                    end
                %cell arrays: depending on what the cell array contains,
                %translate differently. NOTE: known bug: this assumes that
                %the cell array contains all one type of data, and will
                %error if it encounters another type.
                case 'cell'
                    switch class(Vals{i}{1})
                        case 'double'
                            %for a cell array of values, concatenate into a
                            %normal array, convert to string, and print
                            result = [result, sprintf(['#TYPE cell double ' F{i} ' = ' num2str([Vals{i}{:}]) '\n'])];
                        case 'char'
                            %Can't concatenate a character cell array,
                            %spaces are lost. Therefore, print one at a
                            %time with spaces inserted
                            tempstr = ['#TYPE cell char ' F{i} ' = '];
                            for j = 1:length(Vals{i})
                                tempstr = [tempstr, Vals{i}{j} ' '];
                            end
                            tempstr = [tempstr, '\n'];
                            result = [result, sprintf(tempstr)];
                        otherwise
                            error([F{i} ' contains a cell array of unknown type ' class(Vals{i}{1})]);
                    end
                %Numbers: convert to string and print    
                case 'double'
                    result = [result, sprintf(['#TYPE double ' F{i} ' = ' num2str(Vals{i}) '\n' ])];
                %Structures: Display #CATEGORY tag for reimporting, then
                %recusively call structcrawl again.
                case 'struct'
                    result = [result, sprintf(['#CATEGORY ' F{i} ' of '])];
                    for j  = 1 : length(parent)
                        result = [result, sprintf([parent{j} ' '])];
                    end
                    result = [result,sprintf('\n')];
                    parents = [parent ,F(i)];
                    result = [result, structcrawl(Vals{i},type,parents)];
                    result = [result, sprintf('#END \n')];
                case 'char'
                    %In filepaths, the '\' characters must be converted to
                    %'\\' in order to avoid erroneous escape sequences.
                    tempstr = strrep(Vals{i}, '\' , '\\');
                    
                    result = [result, sprintf(['#TYPE char ' F{i} ' = ' tempstr ' \n'])];
                otherwise
                    error([F{i} ' has unknown type ' Class]);
            end
        case 'latex'
            %TBD: latex text using itemize states
        otherwise
            error([type ' is an unknown display type.']);
    end
end

end
